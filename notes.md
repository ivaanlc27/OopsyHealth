I’m building a vulnerable telemedicine web app called OopsyHealth as a Dockerized lab for a cybersecurity master’s practical. The base user is a patient; the lab will provide an initial patient account so students can jump straight in. The site’s landing page will be styled for telemedicine and include a login panel and a classic “forgot password” field to trigger the reset flow.

After logging in, the standard patient can view a set of medical reports (lab results, prescriptions, etc.). The first intentional flaw is an IDOR: report pages use a report ID in the URL without verifying ownership, so changing that ID in the URL lets a patient view other users’ reports. Every patient has an assigned pharmacist (usernames follow the firstname.lastname format), and that pharmacist account exists with the pharmacist role. Patients can upload files (for example, a prescription request). There will be client-side checks for file type and maximum size (a second, easily bypassed weakness), and server-side checks that blacklist common executable extensions such as .php, .phar, .phpt, .php3, .php5, etc. However, the app will accept uploads like .htaccess and allow an attacker to include directives that force the server to interpret an arbitrary extension (for example .test) as PHP. Because the server records where uploads are stored and makes them accessible, this enables a classic insecure-file-upload exploit: an attacker can upload a crafted .htaccess plus a .test web shell and then execute it.

The password reset mechanism is deliberately flawed. When a user requests a reset, the app asks for an email and issues a token stored in the database together with an expiration timestamp. The vulnerability is that the token is not bound to the user account for which it was issued: the database only records the token and expiry, not which user it was generated for. That means if you request a token for one email, you can reuse that token to reset the password of another account (token reuse), as long as the token exists and hasn’t expired. After the token is validated, the flow asks for a numeric OTP (three digits) that is “sent” to the mobile number associated with the email; the OTP is generated and stored in the database but the delivery is simulated. There is no limit on attempts and the OTP space is tiny, so tools like ffuf can brute-force the OTP and allow a student to set a new password for a higher-privilege account such as a pharmacist.

Pharmacists get a different interface and, like patients, each pharmacist is associated with a doctor. The app uses JWTs signed with HMAC-SHA256 for authentication. To teach secret-leak scenarios, the database will contain the secret used to sign JWTs. With that secret an attacker can decrypt, modify, and re-sign JWTs and escalate a pharmacist session into a doctor session. The pharmacist can also query medication availability with a SQL-backed endpoint that is vulnerable to blind SQL injection, allowing data exfiltration via substring-style payloads. Another pharmacist view that returns drug details is vulnerable to Local File Inclusion; combined with log-poisoning techniques, the pharmacist can read system files or web server logs. There is also a chat between pharmacist and doctor: because the pharmacist can edit their own biography and will be able to infer the API used to update profiles, the pharmacist can craft stored XSS payloads in chat messages. When the doctor reads the message, the stored XSS can execute and perform authenticated requests (CSRF), for example automatically changing the doctor’s biography. The app will prevent direct profile edits of other users to force students to chain stored XSS into CSRF to achieve that effect.

Finally, the doctor’s panel will allow the doctor to read chats with associated pharmacists and will intentionally include a Server-Side Template Injection vulnerability (for example via an unsafe Mako template usage). SSTI will give an attacker who controls or forges a doctor session a path to execute code inside the container and access sensitive files. The Docker environment itself will be intentionally vulnerable to a breakout scenario so students can learn container hardening and host-level mitigations; we can refine the exact breakout technique later.

The whole point of OopsyHealth is to provide a realistic, contextualized environment where students can practice exploiting these flaws and, crucially, learn how to fix them.